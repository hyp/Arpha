#
	This module defines arpha's syntax.
	Author: Hyp
	Version: 1
#

import export types

import qualified precedence

import export ast

#TODO condition typecheck?
macro if {
	#must have if and else
	macro ifElse {
		parser.expect("(")
		var condition = parser.parse()
		parser.expect(")")
		var consequence = parser.parse()
		parser.expect("else")
		var alternative = parser.parse()
		return ast.newIfElse(condition,consequence,alternative)		
	}
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	var consequence = parser.parse()
	var alternative = ifElse(parser.match("else",ignoreNewlines:true)) parser.parse() else [> () <]
	return ast.newIfElse(condition,consequence,alternative)
}

#TODO condition typecheck?
macro continue = ast.newControlFlow(continue:true)
macro break = ast.newControlFlow(break:true)

macro while {
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	var body = parser.parse()
	return ast.newLoop([> if(not($condition)) break else $body <] )
}

macro until {
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	var body = parser.parse()
	return ast.newLoop([> if($condition) break else $body <] )
}

macro loop {
	var body = parser.parse()
	if(parser.match("while",ignoreNewlines:true)){
		parser.expect("(")
		var condition = parser.parse()
		parser.expect(")")
		return ast.newLoop([> $body ; if(not($condition)) break <] )
	} 
	else if(parser.match("until",ignoreNewlines:true)){
		parser.expect("(")
		var condition = parser.parse()
		parser.expect(")")
		return ast.newLoop([> $body ; if($condition) break <] )
	} 
	else return ast.newLoop([> $body <] )
}


# TODO
macro for {
	parser.expect("(")
	var vname = parser.symbol()
	parser.expect("in")
	var container = parser.parse()
	parser.expect(")")
	var body = parser.parse()
	return [>
		def sequence = $container
		while(sequence.isEmpty){
			def i = sequence.front
			$body
			sequence.popFront()
		}
	<]
}


#TODO
macro [ {
	var expr = parser.parse()
	parser.expect("]")
	return [> $expr <]
}

macro & {
	var expr = parser.parse(precedence.unary)
	return ast.newPointerOp(expr,addressof:true)
}

macro * {
	var expr = parser.parse(precedence.unary)
	return [> derefOrPtrType($expr) <]
}
macro derefOrPtrType(T Type) = [> Pointer($T) <]
macro derefOrPtrType(expr)   = ast.newPointerOp(expr,dereference:true) 

macro [] {
	var expr = parser.parse(precedence.unary)
	return [> Range($expr) <]
}

import export operators

import export operations

# A default heap allocator used to allocate objects with new
constraint anyType(T) = T == Type
macro allocator(T anyType) = [> <]

#
	New is used to create a new instance of an object not on the stack
	Note:
		In order to use custom memory allocator, you will have to implement
		a property "allocator" for your type. 
#
macro new {
	var type = parser.parse(precedence.call)
	if(parser.match("(")){
		if(!parser.match(")")){
			var arg = parser.parse()
			parser.expect(")")
			return [> $type.allocator.alloc(sizeof($type)).construct($arg) <]
		}
	}
	return [> $type.allocator.alloc(sizeof($type)).construct() <]
}

#
	Delete is used to delete an instance of an object which resides not on the stack
	Note:
		In order to use custom memory allocator, you will have to implement
		a property "allocator" for your type. 
#
macro delete {
	var object = parser.parse() #TODO type check is ptr..
	return [> $object.finalize(); typeof($object).allocator.free($object) <]
}



# An unsigned integer representing CPU's word.
# It is equivalent to size_t from C/C++.
#def natural = if(true) uint32 else uint64

#import export operators



#import export qualified compiler

#import export operations
