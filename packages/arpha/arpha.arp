#
	This module defines arpha's syntax.
	Author: Hyp
	Version: 1
#

import export types

macro Nothing = ast.newTypeExpression(0)
macro Type    = ast.newTypeExpression(1)
macro bool    = ast.newTypeExpression(2)

macro false = ast.newBooleanConstant(0)
macro true  = ast.newBooleanConstant(1)

import qualified precedence

import export ast

#TODO condition typecheck?
macro if {
	#must have if and else
	macro ifElse {
		parser.expect("(")
		var condition = parser.parse()
		parser.expect(")")
		var consequence = parser.parse()
		parser.expect("else")
		var alternative = parser.parse()
		return ast.newIfElse(condition,consequence,alternative)		
	}
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	var consequence = parser.parse()
	parser.matchNewline()
	var alternative = ifElse(parser.match("else")) parser.parse() else [> () <]
	return ast.newIfElse(condition,consequence,alternative)
}

#TODO condition typecheck?
macro while {
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	return ast.newWhile(condition,parser.parse())
}

#TODO remove integer hack with a predefined constant
macro continue = ast.newControlFlow(0)
macro break = ast.newControlFlow(1)

# TODO
macro for {
	parser.expect("(")
	var vname = parser.symbol()
	parser.expect("in")
	var container = parser.parse()
	parser.expect(")")
	var body = parser.parse()
	return [> while(false) $body <]
}

#TODO
macro [ {
	var expr = parser.parse()
	parser.expect("]")
	return [> $expr <]
}

macro & {
	var expr = parser.parse(precedence.unary)
	return ast.newPointerOp(0,expr)
}

macro ^ {
	var expr = parser.parse(precedence.unary)
	return [> derefOrPtrType($expr) <]
}
macro derefOrPtrType(T Type) = ast.newTypeExpression(7,T)
macro derefOrPtrType(expr)   = ast.newPointerOp(1,[> () <] )

import export operators

import export operations

#
macro new {
	var type = parser.parse(precedence.call)
	if(parser.match("(")){
		if(!parser.match(")")){
			var arg = parser.parse()
			parser.expect(")")
			return [> construct($type.allocator.alloc(sizeof($type)),$arg) <]
		}
	}
	return [> construct($type.allocator.alloc(sizeof($type))) <]
}

macro delete {
	var object = parser.parse() #type check is ptr..
	return [> $object.finalize(); typeof($object).allocator.free($object) <]
}
#

# Returns true if two given types are the same type. TOCONSIDER move to compiler
def equals(x Type,y Type) bool


# Returns the type of a given expression.
#macro typeof(expression) Type

# Returns the size(in bytes) of a given type. If an expression was given instead, returns the size of that expression's type.
#macro sizeof(expression) uint32


# An unsigned integer representing CPU's word.
# It is equivalent to size_t from C/C++.
#def natural = if(true) uint32 else uint64

#import export operators



#import export qualified compiler

#import export operations
