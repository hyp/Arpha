#
	This module defines arpha's syntax.
	Author: Hyp
	Version: 1
#

import export types

import qualified precedence

def false bool = 0
def true bool = 1

import export ast

#TODO condition typecheck?
macro while {
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	return ast.newWhile(condition,parser.parse())
}

# If macro TODO
macro if {
	parser.expect("(")
	var condition = parser.parse()
	parser.expect(")")
	var consequence = parser.parse()
	var alternative = match parser.match("else") {
		to(true)	parser.parse()
		to(false)   [> () <]
	}
	return [> match condition { 
		to(true) consequence
		to(false) alternative
	} <]
}

# TODO
macro for {
	parser.expect("(")
	var vname = parser.symbol()
	parser.expect("in")
	var container = parser.parse()
	parser.expect(")")
	var body = parser.parse()
	return [> while(false) body <]
}

#TODO
macro [ {
	var expr = parser.parse()
	parser.expect("]")
	return [> expr <]
}


import export operators

import export operations

# Returns true if two given types are the same type. TOCONSIDER move to compiler
def equals(x Type,y Type) bool

# Returns the type of a given expression.
#macro typeof(expression) Type

# Returns the size(in bytes) of a given type. If an expression was given instead, returns the size of that expression's type.
#macro sizeof(expression) uint32


# An unsigned integer representing CPU's word.
# It is equivalent to size_t from C/C++.
#def natural = if(true) uint32 else uint64

#import export operators



#import export qualified compiler

#import export operations
