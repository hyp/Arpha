#
	This module defines arpha's syntax.
	Author: Hyp
	Version: 1
#

import export types

import qualified precedence

def false bool = 0
def true bool = 1

macro parentheses(expression) syntax("(",optional(expression),")") = expression

macro nothing() syntax("nothing") = ()
	
#macro call(object,argument) syntax(object,precedence(precedence.call) "(",optional(argument),")")

#macro assignment(object,value) syntax(object,precedence(precedence.assignment) "=",precedence(precedence.assignment - 1) value)

#macro index(object,argument) syntax(object,precedence(arpha.precedence.index) "[",argument,"]")

macro while(condition,body) syntax("while","(",condition,")",body)

macro if(condition,consequence,alternative) syntax("if","(",condition,")",consequence,optional("else",alternative)) {
	return match condition {
		to(true) consequence
		to(false) alternative
	}
}

#TODO tuple generation, precedence
macro range(begin,end) syntax(begin,precedence(precedence.index) "..",end) = begin
#TODO array expr, typechecks
macro array(elements) syntax("[",elements,"]") = elements




# TODO proper and argument name
macro for(sequence,body) syntax("for","(","i","in",sequence,")",body) {
#
	var r = sequence.begin()
	while(r != sequence.end()){
		arpha.ast.defineVariable("i") = r
		body
		r.inc()
	}
#
	def i = 1
	body
}

# TODO generation + name
macro unittest(body) syntax("unittest",body) {
	def test() {
		#print("Running unittest")
		body
	}
}

# Returns true if two given types are the same type. TOCONSIDER move to compiler
def equals(x Type,y Type) bool

# Returns the type of a given expression.
macro typeof(expression) Type

# Returns the size(in bytes) of a given type. If an expression was given instead, returns the size of that expression's type.
macro sizeof(expression) uint32


# An unsigned integer representing CPU's word.
# It is equivalent to size_t from C/C++.
def natural = if(true) uint32 else uint64

#
# Literal constant strings
def stringLiteral = String #HACK type "String" is temporary for now
#

import export operators

import export qualified ast

import export qualified compiler

import export operations

# TODO
macro new(T Type,expression) syntax("new",precedence(precedence.call) T,optional("(",expression,")")) {
	#
	match equals(T,int32) {
		to(true) 1
		to(false) ()
	}
	def ptr *T = allocate(T,1) #= allocate(T,1) #TODO sizeof(T)
	construct(ptr) #TODO args
	return ptr
	#
	return 2
}

## Is TODO T Type check
macro is(expression,T) syntax(expression,precedence(precedence.isas) "is", precedence(precedence.isas) T) = typeof(expression) == T

#

# Real assert #TODO(Lates) implementation
def assert(file stringLiteral,line natural,expression stringLiteral)
# Wrapper, currently implemented by compiler
def assert(expression compiler.Expression)
#
