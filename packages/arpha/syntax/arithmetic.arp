#
	This module implements arpha's arithmetic operators.
	Author: Hyp
	Version: 1
#

import qualified precedence

macro - 
{
	var expr = parser.parse(precedence.unary)
	return [> $expr.minus() <]
}

macro + 
{
	var expr = parser.parse(precedence.unary)
	return [> $expr.plus() <]
}

# Binary operators

use precedence: precedence.term
macro (x) + 
{
	var y = parser.parse(precedence.term,ignoreNewlines: true)
	return [> $x.add($y) <]
}

macro (x) - 
{
	var y = parser.parse(precedence.term,ignoreNewlines: true)
	return [> $x.subtract($y) <]
}

use precedence: precedence.product
macro (x) * 
{
	var y = parser.parse(precedence.product,ignoreNewlines: true)
	return [> $x.multiply($y) <]
}

macro (x) / 
{
	var y = parser.parse(precedence.product,ignoreNewlines: true)
	return [> $x.divide($y) <]
}

macro (x) % 
{
	var y = parser.parse(precedence.product,ignoreNewlines: true)
	return [> $x.remainder($y) <]
}

# Assign modify
# TODO possible folding into addAssign etc
use precedence: precedence.assignment
macro (x) += 
{
	var y = parser.parse(precedence.assignment,ignoreNewlines: true)
	return [> $x = $x + $y <]
}

macro (x) -= 
{
	var y = parser.parse(precedence.assignment,ignoreNewlines: true)
	return [> $x = $x - $y <]
}

macro (x) *= 
{
	var y = parser.parse(precedence.assignment,ignoreNewlines: true)
	return [> $x = $x * $y <]
}

macro (x) /= 
{
	var y = parser.parse(precedence.assignment,ignoreNewlines: true)
	return [> $x = $x / $y <]
}

macro (x) %= 
{
	var y = parser.parse(precedence.assignment,ignoreNewlines: true)
	return [> $x = $x % $y <]
}
