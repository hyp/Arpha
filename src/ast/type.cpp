#include "../base/base.h"
#include "../base/bigint.h"
#include "../base/symbol.h"
#include "../base/system.h"
#include "../compiler.h"
#include "node.h"
#include "declarations.h"
#include "visitor.h"
#include "interpret.h"
#include "resolve.h"
#include "../intrinsics/types.h"

/**
  This range iterates over all the possible meanings of a given type( direct, subtyping, implicit conversions etc)
*/
struct TypeMeaningsRange {
private:

	void getRecordSubtypes(Record* record,uint32 filters);

	void gatherMeanings(Type* type,uint32 filters);

	struct Match {
		Type* type;
		int   weight;
	};
	std::vector<Match> meanings;
	std::vector<Match>::iterator currMeaning;

	inline void add(Type* type,int weight){ Match m = { type,weight };meanings.push_back(m); }
public:

	TypeMeaningsRange(Type* type,uint32 filters = 0);

	inline bool isEmpty()       { return currMeaning == meanings.end(); }
	inline void advance()       { ++currMeaning; }
	inline Type* currentType()  { return currMeaning->type; }
	inline int   currentWeight(){ return currMeaning->weight; }
};
TypeMeaningsRange::TypeMeaningsRange(Type* type,uint32 filters){
	gatherMeanings(type,filters);
	currMeaning = meanings.begin();
}

Type* TypePatternUnresolvedExpression::type() const {
	assert(kind == TYPE);
	return  _type;
}
TypePatternUnresolvedExpression TypePatternUnresolvedExpression::duplicate(DuplicationModifiers* mods) const {
	TypePatternUnresolvedExpression result;
	if(kind == TYPE) result._type = _type;
	else if(kind == UNRESOLVED) result.unresolvedExpression = unresolvedExpression->duplicate(mods);
	else if(kind == PATTERN) result.pattern = pattern ? pattern->duplicate(mods) : nullptr;
	result.kind = kind;
	return result;
}
void TypePatternUnresolvedExpression::specify(Type* givenType){
	assert(kind == PATTERN && pattern == nullptr);
	assert(givenType->isResolved());
	kind = TYPE;
	_type = givenType;
}

//TODO do this shit properly!
bool TypePatternUnresolvedExpression::deduce(Type* givenType,Scope* container){
	assert(isPattern());
	assert(givenType->isResolved());

	if(pattern){
		PatternMatcher matcher(container,nullptr);//TODO
		if(!matcher.match(givenType,pattern)) return false;
	}
	kind  = TYPE;
	_type = givenType;
	return true;
}
TypePatternUnresolvedExpression::PatternMatcher::IntroducedDefinition* TypePatternUnresolvedExpression::PatternMatcher::lookupDefinition(SymbolID name){
	for(auto i = introducedDefinitions.begin();i!=introducedDefinitions.end();i++){
		if(name == (*i).name) return &(*i);
	}
	return nullptr;
}
void TypePatternUnresolvedExpression::PatternMatcher::introduceDefinition(SymbolID name,Location location,Node* value){
	for(auto i = introducedDefinitions.begin();i!=introducedDefinitions.end();i++){
		if(name == (*i).name) error(location,"Multiple type labels with same name %s exist in this type pattern",name);
	}
	introducedDefinitions.push_back(IntroducedDefinition(name,location,value));
}

bool checkPatternedTypeDeclaration(Scope* scope,SymbolID name){
	if(auto def = scope->lookupPrefix(name)){
		if(def->asOverloadset()) {
			for(::overloads::OverloadRange overloads(scope,name,false);!overloads.isEmpty();overloads.advance()){
				if(overloads.currentFunction()->isTypeTemplate()){
					return true;
				}
			}
		}
	}

	return false;
}

bool TypePatternUnresolvedExpression::PatternMatcher::check(Node* expression,Trait* currentTrait){
	if(auto typeRef = expression->asTypeReference()){ //| int32 //| Concept
		if(auto concept = typeRef->type->asTrait()){
			if(currentTrait == concept) return true; 
		}
		return typeRef->type->isResolved();
	}
	else if(auto tpref = expression->asTraitParameterReference()){
		return true;
	}
	else if(auto ptr = expression->asPointerOperation()){
		if(ptr->isDereferenceOrType() && check(ptr->expression,currentTrait)){
			if(!ptr->label().isNull()) introduceDefinition(ptr->label(),ptr->location());
			return true;
		}
	}
	else if(auto unresolved = expression->asUnresolvedSymbol()){
		auto symbol = unresolved->symbol;
		if(symbol == "_"){
			if(!unresolved->label().isNull()) introduceDefinition(unresolved->label(),unresolved->location());
			return true; //|_ | T:_
		}
		//T
		if(lookupDefinition(symbol)) return true;
		else if(checkPatternedTypeDeclaration(container,symbol)){
			if(!unresolved->label().isNull()) introduceDefinition(unresolved->label(),unresolved->location());
			return true;
		}
	} else if(auto ref = expression->asFunctionReference()){
		//Constraint
		if(ref->function->isFlagSet(Function::CONSTRAINT_FUNCTION) && ref->function->isResolved()){
			if(!ref->label().isNull()) introduceDefinition(ref->label(),ref->location());
			return true;
		}
	} else if(auto call = expression->asCallExpression()){
		//| Pointer(_) i.e. a Type generated by a function
		bool resolvedObject = false;
		int numberOfParams = -1;
		if(auto callingUnresolvedFunction = call->object->asUnresolvedSymbol()){
			resolvedObject = checkPatternedTypeDeclaration(container,callingUnresolvedFunction->symbol);
		} else if(auto ref = call->object->asFunctionReference()){
			if(ref->function->isFlagSet(Function::CONSTRAINT_FUNCTION) && ref->function->isResolved()) resolvedObject = true;
		} else if(auto typeRef = call->object->asTypeReference()){
			if(auto concept = typeRef->type->asTrait()){
				if(currentTrait == concept || concept->isResolved()){
					numberOfParams = concept->numberOfTemplateParameters();
					resolvedObject = true;
				}
			}
		}
		if(resolvedObject){
			if(!call->label().isNull()) introduceDefinition(call->label(),call->location());
			//Check the parameters..
			if(auto argTuple = call->arg->asTupleExpression()){
				for(auto i = argTuple->children.begin();i!=argTuple->children.end();i++){ if(!check(*i)) return false; }
				if(numberOfParams != -1 && numberOfParams != argTuple->size()) return false;
				return true;
			}
			else {
				if(numberOfParams != -1 && numberOfParams != 1) return false;
				return check(call->arg);
			}
		}
	} else if(auto var = expression->asVariableReference()){
		if(lookupDefinition(var->variable->label())) return true;
	}
	return false;
}
//Evaluates the verifier to see if an expression satisfies a constraint
bool satisfiesConstraint(Node* arg,Function* constraint,Scope* expansionScope){
	assert(constraint->arguments.size() == 1);
	
	CTFEinvocation i(compiler::currentUnit(),constraint);
	if(i.invoke(arg)){
		if(auto resolved = i.result()->asBoolExpression()){
			return resolved->value;
		}
	}
	error(arg,"Can't evaluate constraint %s with argument %s at compile time:\n\tCan't evaluate expression %s!",constraint->label(),arg,i.result());
	return false;
}
bool TypePatternUnresolvedExpression::PatternMatcher::match(Type* type,Node* pattern,Scope* expansionScope){
	this->expansionScope = expansionScope? expansionScope : container;
	notAllResolvedMatch = false;
	auto ref = new TypeReference(type);
	if(match(ref,pattern)) return true;
	

	return false;
}

Type* TypePatternUnresolvedExpression::PatternMatcher::matchWithSubtyping(Type* type,Node* pattern,Scope* expansionScope,uint32 filters){
	this->expansionScope = expansionScope? expansionScope : container;
	notAllResolvedMatch = false;

	auto ref = new TypeReference(type);
	if(match(ref,pattern)) return type;
	else {
		Type* matchedType = nullptr;
		for(TypeMeaningsRange meanings(type,filters);!meanings.isEmpty();meanings.advance()){
			ref->type = meanings.currentType();
			if(match(ref,pattern)){
				if(matchedType){
					error(pattern,"Type pattern matching ambiguity: given %s can become %s and %s",type,matchedType,meanings.currentType());
				}
				matchedType = meanings.currentType();
			}
		}
		return matchedType;
	}
	return nullptr;
}

bool matchOnePatternedTypeDeclaration(Scope* scope,SymbolID name,Type* givenType){
	for(::overloads::OverloadRange overloads(scope,name,false);!overloads.isEmpty();overloads.advance()){
		if(overloads.currentFunction()->isTypeTemplate()){
			auto function = overloads.currentFunction();
			if(givenType->wasGeneratedBy(function)) return true;
		}
	}
	return false;
}

/**
  Checks if a given type satisfies a certain trait from the perspective of a given scope.
  Returns true if a type satisfies trait
  Scenarios:
  requires def foo(x int32) int32 given def foo(x int32) int32

  requires def foo(x Trait) Trait given def foo(x TraitImplementation) TraitImplementation
                                  given def foo(x *TraitImplementation) *TraitImplementation
  requires def foo(x *Trait)      given def foo(x *TraitImplementation) 
  requires def foo(x TraitParameter) given def foo(x int32)
                                     given def foo(x *int32)
  requires def foo(x *TraitParameter) given def foo(x *int32)
*/
bool match(Type* pattern,Type* given,bool strict){
	return pattern->isSame(given) || (!strict && (given->isPointer() && pattern->isSame(given->next())) );
}

bool matchTraitParameter(Node** pattern,Type* given,bool strict){
	if(*pattern){
		return match((*pattern)->asTypeReference()->type,given,strict);
	}
	else {
		if(given->isReference()) given = given->next();
		*pattern = new TypeReference(given);
		return true;
	}
}

// self Foo matches  self Concept
// self Foo.meanings matches self Concept
bool matchConceptToConcrete(Type* given,Type* arg,bool strict){
	if(given->isSame(arg)) return true;

	if(strict) return false;

	for(TypeMeaningsRange meanings(given);!meanings.isEmpty();meanings.advance()){
		if(meanings.currentType()->isSame(arg)) return true;
	}
	return false;
}

// self Foo(_) matches self Concept
// self Foo(_).meanings matches self Concept
Type* matchConceptToPattern(Type* given,TypePatternUnresolvedExpression::PatternMatcher& matcher,Node* pattern,bool strict){
	if(!strict){
		if(auto t = matcher.matchWithSubtyping(given,pattern)){
			return t;
		}
	} else if(matcher.match(given,pattern)) return given;
	return nullptr;
}

data::ast::Search::Result functionMatchesTraitsMethod(Type* type,Trait* trait,Function* function,Function* method,std::vector<Node*>* traitExpansions,Resolver* resolver){
	bool patterned = false;
	TypePatternUnresolvedExpression::PatternMatcher patternedMatcher(function->parameterPatternMatchingScope(),nullptr);
	std::vector<Type*> specializedParameters;
	if(function->isFlagSet(Function::MACRO_FUNCTION)) return data::ast::Search::NotFound;

	if(function->isFlagSet(Function::HAS_PATTERN_ARGUMENTS) || function->isIntrinsicOperation()){
		if(function->isFlagSet(Function::HAS_EXPENDABLE_ARGUMENTS)) return data::ast::Search::NotFound;
		specializedParameters.resize(function->arguments.size(),nullptr);
		patterned = true;
	}

	bool strict = false;

	if(function->arguments.size() == method->arguments.size()){
		for(size_t i =0,s = function->arguments.size();i<s;++i){
			if(method->arguments[i]->type.isResolved()){
				if(function->arguments[i]->type.isResolved() && method->arguments[i]->type.type()->isSame(function->arguments[i]->type.type())){
					continue;
				}
			}
			else if(method->arguments[i]->type.isPattern()){
				auto pattern = method->arguments[i]->type.pattern;
				if(auto ptr = pattern->asPointerOperation()){
					assert(ptr->isDereferenceOrType());
					pattern = ptr->expression;
				}

				if(auto tref = pattern->asTypeReference()){
					auto concept = tref->type->asTrait();
					if(concept != trait) return data::ast::Search::NotFound;

					if(function->arguments[i]->type.isResolved()){
						if(matchConceptToConcrete(type,function->arguments[i]->type.type(),strict)) continue;
					}
					else if(function->arguments[i]->type.isPattern()){
						if(auto t = matchConceptToPattern(type,patternedMatcher,function->arguments[i]->type.pattern,strict)){
							specializedParameters[i] = t;
							continue;
						}
					}
				}
				else if(auto p = pattern->asTraitParameterReference()){
					if(function->arguments[i]->type.isResolved()){
						if(matchTraitParameter((traitExpansions->begin() + p->index)._Ptr,function->arguments[i]->type.type(),strict)) continue;
					}
				}
			}
			return data::ast::Search::NotFound;
		}

		if(patterned){
			if(function->isIntrinsicOperation()){
				auto op = function->getOperation();

				if(method->_returnType.isResolved() && function->_returnType.isResolved()){
					if(method->_returnType.type()->isSame(function->_returnType.type())) return data::ast::Search::Found;
				}
				else if(method->_returnType.isPattern()){
					Type* t;

					if(function->_returnType.isResolved()) t= function->_returnType.type();
					else {
						if(op == data::ast::Operations::ELEMENT_GET){
							assert(type->isLinearSequence());
							t = Type::getReferenceType(type->next());
						}
					}

					if(auto p = method->_returnType.pattern->asTraitParameterReference()){
						if(matchTraitParameter((traitExpansions->begin() + p->index)._Ptr,t,strict)) return data::ast::Search::Found;
					}
				}
				return data::ast::Search::NotFound;				
			}
			else {
				function = resolver->specializeFunction(patternedMatcher,function,specializedParameters.begin()._Ptr,nullptr);
				if(!function->isResolved()){
					if(!resolver->resolveSpecialization(function)){
						return data::ast::Search::NotAllElementsResolved;
					}
				}
			}
		}

		if(method->_returnType.isResolved() && function->_returnType.isResolved()){
			if(method->_returnType.type()->isSame(function->_returnType.type())) return data::ast::Search::Found;
		}
		else if(method->_returnType.isPattern()){
			if(auto p = method->_returnType.pattern->asTraitParameterReference()){
				if(matchTraitParameter((traitExpansions->begin() + p->index)._Ptr,function->_returnType.type(),strict)) return data::ast::Search::Found;
			}
		}
	}
	return data::ast::Search::NotFound;
}

//returns Found if the type satisfies trait
data::ast::Search::Result typeSatisfiesTrait(Scope* scope,Type* type,Trait* trait,Resolver* resolver,std::vector<Node*>* traitExpansions){
	if(!trait->isImplicit()){
		if(auto record = type->asRecord()){
			if(!record->declaration->extendsConcept(trait)) return data::ast::Search::NotFound;
		}
		else if(auto ls = type->isLinearSequence()){
			if(!Type::generators::linearSequence->getTemplateTypeDeclaration()->resolveExtendedConcepts(resolver)) return data::ast::Search::NotAllElementsResolved;
			if(!Type::generators::linearSequence->getTemplateTypeDeclaration()->extendsConcept(trait))             return data::ast::Search::NotFound;
		}
		else return data::ast::Search::NotFound;
	}

	for(auto i = trait->methods.begin();i!=trait->methods.end();i++){
		bool matchFound = false;

		for(::overloads::OverloadRange overloads(scope,(*i)->label(),true);!overloads.isEmpty();overloads.advance()){
			if(!overloads.currentFunction()->isResolved()) return data::ast::Search::NotAllElementsResolved;
			auto matches =functionMatchesTraitsMethod(type,trait,overloads.currentFunction(),(*i),traitExpansions,resolver);
			if(matches == data::ast::Search::Found){
				matchFound = true;
				break;
			}
			else if(matches == data::ast::Search::NotAllElementsResolved) return data::ast::Search::NotAllElementsResolved;
		}
		if(!matchFound) return data::ast::Search::NotFound;
	}
	return data::ast::Search::Found;
}

inline data::ast::Search::Result typeSatisfiesTrait(Scope* scope,Type* type,Trait* trait,Resolver* resolver){
	std::vector<Node*> traitExpansions;
	if(trait->templateDeclaration) traitExpansions.resize(trait->numberOfTemplateParameters(),nullptr);
	return typeSatisfiesTrait(scope,type,trait,resolver,&traitExpansions);
}

bool TypePatternUnresolvedExpression::PatternMatcher::match(Node* object,Node* pattern){

	auto typeRef = object->asTypeReference();
	auto type = typeRef ? typeRef->type : nullptr;
	//_ | T
	if(auto unresolved = pattern->asUnresolvedSymbol()){
		auto symbol = unresolved->symbol;
		if(symbol == "_"){
			if(!unresolved->label().isNull()) introduceDefinition(unresolved->label(),unresolved->location(),object);
			return true; //|_ | T:_
		}
		//T
		if(auto def = lookupDefinition(symbol)){
			if(auto vt = def->value->asTypeReference())
				return type && type->isSame(vt->type);
			else return object->isSame(def->value);
		}
		else if(type){
			if(!type->wasGenerated()) return false;
			if(matchOnePatternedTypeDeclaration(container,symbol,type)){
				if(!unresolved->label().isNull()) introduceDefinition(unresolved->label(),unresolved->location(),object);
				return true;
			}
		}
	} else if(auto var = pattern->asVariableReference()){ //shadowed T
		if(auto def = lookupDefinition(var->variable->label())){
			if(auto vt = def->value->asTypeReference())
				return type && type->isSame(vt->type);
			else return object->isSame(def->value);
		}
	}

	if(!type){
		assert(false && "Invalid matching");
		return false;
	}
	//Match(type)
	if(auto type2 = pattern->asTypeReference()){
		//| Concept
		if(auto concept = type2->type->asTrait()){
			auto matches= typeSatisfiesTrait(expansionScope,type,concept,resolver);
			if(matches == data::ast::Search::Found){
				if(!pattern->label().isNull()) introduceDefinition(pattern->label(),pattern->location(),object);
				return true;
			}
			else if(matches == data::ast::Search::NotAllElementsResolved){
				notAllResolvedMatch = true;
				return false;
			}
		}
		//| int32
		else return type->isSame(type2->type); 
	}
	else if(auto ptr = pattern->asPointerOperation()){
		if(type->isPointer()){
			if(!ptr->label().isNull()) introduceDefinition(ptr->label(),ptr->location(),object);
			return match(new TypeReference(type->next()),ptr->expression);
		}
	}
	else if(auto ref = pattern->asFunctionReference()){
		//Constraint (We can safely assume this is a constraint if check passed)
		if(satisfiesConstraint(typeRef,ref->function,container)){
			if(!ref->label().isNull()) introduceDefinition(ref->label(),ref->location(),typeRef);
			return true;
		}
	} 
	else if(auto call = pattern->asCallExpression()){
		//TODO: NB: maybe check if a type has other meanings if(!type->wasGenerated()) return false;
		bool matchedObject = false;
		Type* matchedType = type;
		//| Pointer(_)
		if(auto callingUnresolvedFunction = call->object->asUnresolvedSymbol()){
			if(!type->wasGenerated()) return false;
			if(matchOnePatternedTypeDeclaration(container,callingUnresolvedFunction->symbol,type)){
				matchedObject = true;
				matchedType = type;
			}
		} 
		else if(auto ref = call->object->asFunctionReference()){
			//Constraint (We can safely assume this is a constraint if check passed)
			if(satisfiesConstraint(typeRef,ref->function,container)) matchedObject = true;
		}
		else if(auto type2 = call->object->asTypeReference()){
			auto concept = type2->type->asTrait();

			std::vector<Node*> traitExpansions;
			if(concept->templateDeclaration) traitExpansions.resize(concept->numberOfTemplateParameters(),nullptr);
			auto matches = typeSatisfiesTrait(expansionScope,type,concept,resolver,&traitExpansions);
			
			if(matches == data::ast::Search::Found){
				//Match parameters..
				if(!call->label().isNull()) introduceDefinition(call->label(),call->location(),typeRef);
				if(auto argTuple = call->arg->asTupleExpression()){
					size_t j = 0;
					for(auto i = argTuple->children.begin();i!=argTuple->children.end();i++,j++){ if(!match(traitExpansions[j],*i)) return false; }
					return true;
				}
				else return match(traitExpansions[0],call->arg);
			}
			else if(matches == data::ast::Search::NotAllElementsResolved){
				notAllResolvedMatch = true;
				return false;
			}
		}
		if(matchedObject){	
			//Match parameters..
			if(!call->label().isNull()) introduceDefinition(call->label(),call->location(),typeRef);
			if(auto argTuple = call->arg->asTupleExpression()){
				size_t j = 0;
				for(auto i = argTuple->children.begin();i!=argTuple->children.end();i++,j++){ if(!match(matchedType->generatedArgument(j),*i)) return false; }
				return true;
			}
			else return match(matchedType->generatedArgument(0),call->arg);
		}
	} 
	return false;
}

void TypePatternUnresolvedExpression::PatternMatcher::defineIntroducedDefinitions(){
	//TODO check if the scope already contains them..
	for(auto i= introducedDefinitions.begin();i!=introducedDefinitions.end();i++){
		auto var = new Variable((*i).name,(*i).location);
		var->_owner = container;
		var->setFlag(Variable::IS_IMMUTABLE);
		if((*i).value){
			var->specifyType((*i).value->returnType());
			var->setImmutableValue((*i).value);
		}else{
			//TODO def f(x T:_) = T define T with no value
		}
		container->define(var);
	}
}


/**
* The type
*/
Function* Type::generators::reference  = nullptr;
Function* Type::generators::linearSequence  = nullptr;
Function* Type::generators::functionPointer = nullptr;
Function* Type::generators::staticArray = nullptr;
Function* Type::generators::vector = nullptr;
Function* Type::generators::tuple = nullptr;

Function* Type::generators::constQualifier = nullptr;

Type::Type(int kind) : type(kind),flags(0) {
	if(kind == BOOL) bits = 1;
}
Type::Type(int kind,Type* next) : type(kind),flags(0) {
	this->argument = next;
}
Type::Type(int kind,int subtype) : type(kind),flags(0) {
	nodeSubtype = subtype;
}

Type* Type::getIntegerType(int bits,bool isSigned){
	return new Type(INTEGER,isSigned? -bits:bits);
}
Type* Type::getFloatType(int bits){
	return new Type(FLOAT,bits);
}
Type* Type::getCharType(int bits){
	return new Type(CHAR,bits);
}
Type* Type::getNaturalType(){
	auto t = new Type(NATURAL);
	t->bits = 32;//TODO
	return t;
}
Type* Type::getUintptrType(){
	auto t = new Type(UINTPTRT);
	t->bits = 32;//TODO
	return t;
}
Type* Type::getLinearSequence(Type* next){
	return new Type(LINEAR_SEQUENCE,next);
}
Type* Type::getPointerType(Type* next){
	return new Type(Type::POINTER,next);
}
Type* Type::getReferenceType(Type* next){
	return new Type(Type::REFERENCE,next);
}
Type* Type::getConstQualifier(Type* next){
	if(!next->isQualifier()) next = new Type(Type::QUALIFIER,next);
	next->setFlag(CONST_QUALIFIER);
	return next;
}
Type* Type::getLocalQualifier(Type* next){
	if(!next->isQualifier()) next = new Type(Type::QUALIFIER,next);
	next->setFlag(LOCAL_QUALIFIER);
	return next;
}

void Type::setFlag(uint16 flag){
	flags |= flag;
}
bool Type::isFlagSet(uint16 flag) const {
	return (flags & flag) == flag;
}
bool Type::requiresDestructorCall() const {
	switch(type){
		case RECORD:  return true;
	}
	return false;
}
bool Type::isResolved() const {
	switch(type){
		case RECORD:  return isFlagSet(IS_RESOLVED);
		case VARIANT: return isFlagSet(IS_RESOLVED);
		case POINTER:
		case REFERENCE:
		case LINEAR_SEQUENCE:
		case STATIC_ARRAY:
			return argument->isResolved();
		case FUNCTION_POINTER:
			return argument->isResolved() && static_cast<const FunctionPointer*>(this)->returns()->isResolved();
		case TRAIT:
			return static_cast<const Trait*>(this)->isResolved();

		case QUALIFIER:
			return argument->isResolved();
		default:
			return true;
	}
}
//Partially resolved means sizeof(T) would succeed
bool Type::isPartiallyResolved() const {
	switch(type){
	case RECORD:  return isFlagSet(IS_RESOLVED);
	case VARIANT: return isFlagSet(IS_RESOLVED);

	case QUALIFIER:
		return argument->isResolved();
	default:
		return true;
	}
}

bool Type::isSame(Type* other){
	if(this->type != other->type) return false;
	switch(type){
		case VOID: case TYPE: case BOOL: return true;
		case RECORD :
		case VARIANT:
			return this == other;
		case INTEGER:
		case FLOAT:
		case CHAR:  
			return bits == other->bits;
		case NATURAL:
		case UINTPTRT:
			return true;
		
		case POINTER: 
		case REFERENCE:
		case LINEAR_SEQUENCE:
			return argument->isSame(other->argument);
		case STATIC_ARRAY: 
			return argument->isSame(other->argument) && static_cast<StaticArray*>(this)->length() == static_cast<StaticArray*>(other)->length();
		
		case FUNCTION_POINTER: 
			return argument->isSame(other->argument) && 
				static_cast<FunctionPointer*>(this)->returns()->isSame(static_cast<FunctionPointer*>(other)->returns());
		
		case NODE: return nodeSubtype == other->nodeSubtype;
		
		case ANONYMOUS_RECORD:
		case ANONYMOUS_VARIANT:
			return static_cast<AnonymousAggregate*>(this)->types  == static_cast<AnonymousAggregate*>(other)->types &&
				   static_cast<AnonymousAggregate*>(this)->fields == static_cast<AnonymousAggregate*>(other)->fields;

		case VARIANT_OPTION:
			return optionID == other->optionID;

		case TRAIT:
			return this == other;

		case QUALIFIER:
			return flags == other->flags && argument->isSame(other->argument);
		default:
			throw std::runtime_error("TypeExpression type invariant failed");	
			return false;
	}
}
Type* Type::stripQualifiers(){
	return isQualifier()? argument : this;
}
bool Type::hasConstQualifier() const {
	return isQualifier()? isFlagSet(CONST_QUALIFIER) : false;
}
bool Type::hasLocalQualifier() const {
	return isQualifier()? isFlagSet(LOCAL_QUALIFIER) : false;
}
bool Type::wasGenerated() const {
	switch(type){
	case RECORD:  return static_cast<const Record* >(this)->declaration->isParametrized();
	case VARIANT: return static_cast<const Variant*>(this)->declaration->isParametrized();

	case POINTER:
	case REFERENCE:
	case LINEAR_SEQUENCE: 
	case STATIC_ARRAY:    
	case FUNCTION_POINTER: return true;

	case ANONYMOUS_RECORD: return true;
	
	case QUALIFIER:
		return true;
	default: return false;
	}
}
bool Type::wasGeneratedBy(Function* function) const {
	switch(type){
	case RECORD: return static_cast<const Record*>(this)->declaration->parametrization()->generatedFunctionParent == function;

	case REFERENCE:        return function == generators::reference;
	case LINEAR_SEQUENCE:  return function == generators::linearSequence;
	case STATIC_ARRAY:     return function == generators::staticArray;
	case FUNCTION_POINTER: return function == generators::functionPointer;

	case ANONYMOUS_RECORD: return static_cast<const AnonymousAggregate*>(this)->isFlagSet(AnonymousAggregate::GEN_REWRITE_AS_VECTOR)? function == generators::vector : function == generators::tuple;


	default:
		return false;
	}
}
Node* Type::generatedArgument(size_t i) const {
	switch(type){
	case RECORD: return static_cast<const Record*>(this)->declaration->parametrization()->expandedArguments[i];

	case POINTER:
	case REFERENCE:
	case LINEAR_SEQUENCE:
		return new TypeReference(argument);
	case STATIC_ARRAY: 
		return i == 0 ? new TypeReference(argument) : (Node*) new IntegerLiteral((uint64)static_cast<const StaticArray*>(this)->length(),intrinsics::types::natural);
	case FUNCTION_POINTER: return new TypeReference(i == 0 ? argument : static_cast<const FunctionPointer*>(this)->returns());

	case ANONYMOUS_RECORD: if(static_cast<const AnonymousAggregate*>(this)->isFlagSet(AnonymousAggregate::GEN_REWRITE_AS_VECTOR)){
								return i == 0 ? (Node*)new TypeReference(static_cast<const AnonymousAggregate*>(this)->types[0]) :
									 new IntegerLiteral((uint64)static_cast<const AnonymousAggregate*>(this)->numberOfFields,intrinsics::types::natural);
						   } else {
							   return i < static_cast<const AnonymousAggregate*>(this)->numberOfFields? 
								   new TypeReference(static_cast<const AnonymousAggregate*>(this)->types[i]) : nullptr;
						   }
	case QUALIFIER:
		return new TypeReference(argument);

	default:
		throw std::runtime_error("TypeExpression generatedArgument failed");	
		return nullptr;
	}
}

enum {
	CONVERSION_DIFFERENT_KIND = 4,      //integers => float
	CONVERSION_SAME_KIND,           //integers <=> integers
	LITERAL_TYPE_SPECIFICATION, //Untyped literal to typed
	ADDRESSOF,
	RECORD_SUBTYPE,	
	EXACT
};

inline Node* int2float(IntegerLiteral* node,Type* t){
	return new FloatingPointLiteral((double)node->integer.u64,t);
}
inline Node* int2char(IntegerLiteral* node,Type* t){
	return new CharacterLiteral((UnicodeChar)node->integer.u64,t);
}
inline Node* char2int(CharacterLiteral* node,Type* t){
	return new IntegerLiteral((uint64)node->value,t);
}

inline bool characterFits(int bits,uint32 value){
	if(value < 256) return true;
	if(bits == 16 && value <= std::numeric_limits<uint16>::max() ) return true;//TODO is this correct???
	return bits == 32 && value <= 0x10FFFF? true:false; //UNICODE_MAX
}

Type* Type::getBestFitIntegerType(const BigInt& value){
	if(value.isNegative()){
		if(/*>=*/ !(value < (uint64)std::numeric_limits<int32>::min())) return intrinsics::types::int32;
		else return intrinsics::types::int64;
	}
	else{
		if(value <= (uint64)std::numeric_limits<int32>::max()) return intrinsics::types::int32;
		else if(value <= (uint64)std::numeric_limits<uint32>::max()) return intrinsics::types::uint32;
		else if(value <= (uint64)std::numeric_limits<int64>::max()) return intrinsics::types::int64;
		else return intrinsics::types::uint64;
	}
}
bool Type::integerFits(uint64 value,bool isNegative){
	if(isNegative && bits>0) return false;

	int64 min;
	uint64 max;
#define RANGE(T) { min = std::numeric_limits<T>::min() ; max = std::numeric_limits<T>::max() ; }
	if(bits == 32)       RANGE(uint32)
	else if(bits == 64)  RANGE(uint64)
	else if(bits == -32) RANGE(int32)
	else if(bits == 16)  RANGE(uint16)
	else if(bits == -16) RANGE(int16)
	else if(bits == 8)   RANGE(uint8)
	else if(bits == -8)  RANGE(int8)
	else if(bits == -64) RANGE(int64);
	
	if(bits > 0) return value <= max;
	else return ((int64)value) >= min && value <= max;
#undef RANGE
}

bool   Type::doesLiteralFit(IntegerLiteral* node){
	if(isInteger() ||  isPlatformInteger() || isUintptr()){
		return integerFits(node->integer.u64,node->integer.isNegative());
	}
	else {
		assert(isChar());
		if(node->integer.isNegative()) return false;
		return characterFits(bits,node->integer.u64);
	}
}
bool   Type::doesLiteralFit(CharacterLiteral* node){
	if(isInteger()){
		return integerFits(node->value,false);
	}
	else {
		assert(isChar());
		return characterFits(bits,node->value);
	}
}



/*
Given literalNodeType is literal
Scenarios:
  def a = 1 :: literal.integer                => 1 :: literal.integer
  def a int32 = 1 :: literal.integer          => 1 :: int32
  def a literal.float = 1 :: literal.integer  => 1.0 :: literal.float
  def a float = 1 :: literal.integer          => 1.0 :: float
  def c literal.char = 1 :: literal.integer   => '\x01' :: literal.char
  def c char32 = 65 :: literal.integer        => 'A' :: char32

  def x natural = 65 :: literal.integer       => 65  :: natural
  def x uintptr = 65 :: literal.integer       => 65  :: uintptr

  def f float = 2.71 :: literal.float         => 2.71 :: float

  def c char32 = 'A' :: literal.char          => 'A' :: char32
  def c literal.integer = 'A' :: literal.char => 65 :: literal.integer
  def c int32  = 'A' :: literal.char          => 65 :: int32
  def x natural = 'A' :: literal.char         => 65 :: natural

  def s LinearSequence(char8) = "foo" :: literal.string => "foo" :: LinearSequence(char8)
*/
int literalTypeAssignment(Type* givenType,Node** literalNode,Type* literalNodeType,bool doTransform){
	auto expression = *literalNode;

	if( auto integerLiteral = expression->asIntegerLiteral() ){
		// a int32 = 1
		if(givenType->isInteger() && givenType->doesLiteralFit(integerLiteral)){
			if(doTransform) integerLiteral->specifyType(givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
		// a float = 1
		else if(givenType->isFloat()){
			if(doTransform) *literalNode = int2float(integerLiteral,givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
		// a char = 1
		else if( givenType->isChar() && givenType->doesLiteralFit(integerLiteral) ){
			if(doTransform) *literalNode = int2char(integerLiteral,givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
		// a natural/uintptr = 1
		else if( (givenType->isPlatformInteger() || givenType->isUintptr()) && givenType->doesLiteralFit(integerLiteral)){
			if(doTransform) integerLiteral->specifyType(givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
	}
	else if( auto floatingLiteral = expression->asFloatingPointLiteral() ){
		//a float = 1.0
		if(givenType->isFloat()){
			if(doTransform) floatingLiteral->specifyType(givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
	}
	else if( auto characterLiteral = expression->asCharacterLiteral() ){
		//a char32 = 'A'
		if(givenType->isChar() && givenType->doesLiteralFit(characterLiteral) ){
			if(doTransform) characterLiteral->specifyType(givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
		//a int32 = 'A'
		else if( givenType->isInteger() && givenType->doesLiteralFit(characterLiteral) ){
			if(doTransform) *literalNode = char2int(characterLiteral,givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
		// a natural = 'A'
		else if(givenType->isPlatformInteger() /*NB: assume platform integers are >= char32 && givenType->doesLiteralFit(characterLiteral)*/){
			if(doTransform) *literalNode = char2int(characterLiteral,givenType);
			return LITERAL_TYPE_SPECIFICATION;
		}
	}

	return -1;
}
/**
TODO: adjust conversion weights

Scenarios:
  def x uint64 = uint8,uint16,uint32
        uint32 = uint8,uint16
		uint16 = uint8

		int64  = (u)int8,(u)int16,(u)int32
		int32  = (u)int8,(u)int16
		int16  = (u)int8,(u)int16

		natural = uint16,uint32,(m64: uint64)

  def x float  = (u)intX
        double = (u)intX
		double = float

  def c char16 = char8
      c char32 = char8,char16
*/
int automaticTypeCast(Type* givenType,Node** node,Type* nodeType,bool doTransform){
	int weight = -1;

	if(givenType->isInteger() && nodeType->isInteger()){
		//uintX = uint(X-1)
		if(givenType->bits > 0){
			if(nodeType->bits > 0 && nodeType->bits < givenType->bits)
				weight = CONVERSION_SAME_KIND;
		}
		//intX = (u)int(X-1)
		else {
			if(std::abs(nodeType->bits) < -givenType->bits)
				weight = CONVERSION_SAME_KIND;
		}
	}
	else if(givenType->isFloat()){
		if(nodeType->isFloat() && nodeType->bits < givenType->bits)
			weight = CONVERSION_SAME_KIND;
		else if(nodeType->isInteger())
			weight = CONVERSION_DIFFERENT_KIND;
	}
	else if(givenType->isPlatformInteger()){
		//natural = uintX
		if(nodeType->isInteger()){
			if(nodeType->bits > 0 && nodeType->bits < givenType->bits)
				weight = CONVERSION_SAME_KIND;
		}
	}
	else if(givenType->isChar()){
		//charX = char(X-1)
		if(nodeType->isChar()){
			if(nodeType->bits < givenType->bits)
				weight = CONVERSION_SAME_KIND;
		}
	}
	else if(givenType->isLinearSequence()){
		if(nodeType->isStaticArray() && givenType->next()->isSame(nodeType->next()))
			weight = CONVERSION_SAME_KIND;
	}

	if(weight != -1 && doTransform) *node = new CastExpression(*node,givenType);
	return weight;
}

/**
Scenarios:
  type Foo { extends var x int32 ; }
  var foo Foo

  var x int32 = foo , &foo
      x int64 = foo , &foo
  TODO:    x int8  = foo as int8 , &foo as int8

  type Foo : Bar {} ; def bar(x *Bar) ; var foo Foo ; foo.bar &foo.bar

  TODO: NB: The weights are a bit dodgy now
*/
int recordSubtyping(Type* givenType,Node** node,Type* nodeType,bool doTransform){
	Record* record = nodeType->asRecord();
	if(!record){
		if(nodeType->isPointer()){
			record = nodeType->next()->asRecord();
			if(!record) return -1;
		}
		else return -1;
	}

	for(auto field = record->fields.begin(); field != record->fields.end();++field){
		if((*field).isExtending){
			//NB: try to assign without transformations first
			//NB: when transforming make sure to transform the field access as required
			auto assigns = givenType->assignFrom(node,(*field).type.type(),false);
			if(assigns != -1){
				if(doTransform){
					*node = new FieldAccessExpression(*node,(int)(field - record->fields.begin()));
					givenType->assignFrom(node,(*field).type.type(),true);
				}
				return assigns == EXACT? RECORD_SUBTYPE : assigns;
			}
		}
	}
	return -1;
}
void TypeMeaningsRange::getRecordSubtypes(Record* record,uint32 filters){
	for(auto field = record->fields.begin(); field != record->fields.end();++field){
		if((*field).isExtending){
			add((*field).type.type(),RECORD_SUBTYPE);
			gatherMeanings((*field).type.type(),filters);
		}
	}
}

int referenceOf(Type* givenType, Node** node, Type* nodeType,bool doTransform,uint32 filters){
	Type ptrType(Type::POINTER,nodeType);
	int weight = givenType->assignFrom(node,&ptrType,doTransform,filters);
	if(weight != -1){
		if(doTransform){
			*node = new PointerOperation(*node,PointerOperation::ADDRESS);
		}
		return ADDRESSOF;
	}
	return -1;
}

int referenceTo(Type* givenType, Node** node, Type* nodeType,bool doTransform){
	int weight = givenType->assignFrom(node,nodeType->next(),doTransform);
	if(weight != -1){
		if(doTransform){
			*node = new PointerOperation(*node,PointerOperation::DEREFERENCE);
		}
		return ADDRESSOF;
	}
	return -1;
}


/**
Implicit type conversion system.
Returns the weight of the conversion or -1 if the conversion failed.
Scenarios:
	As per above literal,auto and record type casts
	*ast.Call , etc => *ast.Node
	x :: int32    -> &x :: *int32

	x :: Reference (T) -> *x  :: T
	x :: Reference (T) -> x as *T :: *T
*/
int Type::assignFrom(Node** expression,Type* type,bool doTransform,uint32 filters){
	if(this->isSame(type)) return EXACT;
	int assigns;

	if( this->hasConstQualifier() && ((assigns = this->next()->assignFrom(expression,type,doTransform,filters)) != -1) ){
		return assigns;
	}
	else if(!(filters & DisallowAutocasts) && (*expression)->isUntypedLiteral() ){
		return literalTypeAssignment(this,expression,type,doTransform);
	}
	else if( !(filters & DisallowAutocasts) && (assigns = automaticTypeCast(this,expression,type,doTransform)) != -1 ){
		return assigns;
	}
	else if( (assigns = recordSubtyping(this,expression,type,doTransform)) != -1){
		return assigns;
	}
	else if( isNodePointer() && type->isNodePointer() ){
		return RECORD_SUBTYPE;
	}
	else if( isPointer() && !type->isPointer() && (filters & Type::AllowAutoAddressof) && ((assigns = referenceOf(this,expression,type,doTransform,filters)) != -1) ){
		return assigns;
	}
	else if( type->isReference() && !isReference() && ((assigns = referenceTo(this,expression,type,doTransform)) != -1) ){
		return assigns;
	}

	return -1;
}
void TypeMeaningsRange::gatherMeanings(Type* type,uint32 filters){

	Record* record = type->asRecord();
	if(!record){
		if(type->isPointer()){
			record = type->next()->asRecord();
			if(record) getRecordSubtypes(record,filters);
		}
	}
	else getRecordSubtypes(record,filters);

	if(type->isStaticArray()) add(Type::getLinearSequence(type->next()),CONVERSION_SAME_KIND);
	if(!type->isPointer()) add(Type::getPointerType(type),ADDRESSOF);
}



int   Type::canAssignFrom(Node* expression,Type* type,uint32 filters){
	return assignFrom(&expression,type,false,filters);
}
Node* Type::assignableFrom(Node* expression,Type* type,uint32 filters) {
	if(assignFrom(&expression,type,true,filters) != -1) return expression;
	return nullptr;
}

static inline bool isIntLike(Type* t){
	return t->isInteger() || t->isPlatformInteger() || t->isUintptr() || t->isChar();
}
static inline bool isIntOrChar(Type* t){
	return t->isInteger() || t->isChar();
}

Type* Type::getCommon(Node** elements,size_t count){
	auto commonType = elements[0]->returnType();
	auto end = elements+count;
	for(auto i = elements;i!=end;++i){
		auto type = (*i)->returnType();
		if(type->isFloat()){
			if(commonType->isFloat() && type->bits > commonType->bits) commonType = type;
			else if(commonType->isInteger()) commonType = type;
		}
		else if(type->isChar()){
			if(commonType->isChar() && type->bits > commonType->bits) commonType = type;
		}
		else if(type->isInteger()){
			if(commonType->isInteger()){
				if(std::abs(type->bits) > std::abs(commonType->bits)) commonType = type; 
			}
		}
	}
	return commonType;
}

/**
Scenarios:
  integers <=> integers
  integers <=> floats
  integers <=> characters
  floats   <=> floats
  characters <=> characters
  integers <=> bool
  Pointer => uintptr
  Pointer|LinearSequence (uint8 <=> int8 <=> char8,uint16 <=> int16 <=> char16,uint32 <=> int32 <=> char32,uint64 <=> int64)
  
*/
bool  Type::canCastTo(Type* other){
	auto thisIsIntLike  = isIntLike(this);
	auto otherIsIntLike = isIntLike(other);

	if(thisIsIntLike){
		if(otherIsIntLike) return true;
		else if(other->isBool()) return true;
		else if(other->isFloat()) return true;
	}
	else if(this->isFloat()){
		if(otherIsIntLike) return true;
		else if(other->isFloat()) return true;
	}
	else if(this->isBool()){
		if(otherIsIntLike) return true;
	}
	else if(this->isPointer()){
		if(other->isUintptr()) return true;
		if(other->isPointer() &&
			isIntOrChar(next()) && isIntOrChar(other->next()) &&
			std::abs(next()->bits) == std::abs(other->next()->bits)) return true;
	}
	else if(this->isLinearSequence()){
		if(other->isUintptr()) return true;
		if(other->isPointer() && next()->isSame(other->next())) return true;
		if(other->isLinearSequence() &&
			isIntOrChar(next()) && isIntOrChar(other->next()) &&
			std::abs(next()->bits) == std::abs(other->next()->bits)) return true;
	}
	else if(this->isStaticArray()){
		if(other->isLinearSequence() && next()->isSame(other->next())) return true;
	}
	return false;
}

inline Node* bool2int(BoolExpression* node,Type* givenType){
	return new IntegerLiteral((uint64)node->value,givenType);
}
inline Node* char2float(CharacterLiteral* node,Type* givenType){
	return new FloatingPointLiteral(node->value,givenType);
}
inline Node* float2int(FloatingPointLiteral* node,Type* givenType){
	return new IntegerLiteral((uint64)node->value,givenType);
}
inline Node* float2char(FloatingPointLiteral* node,Type* givenType){
	return new CharacterLiteral((UnicodeChar)node->value,givenType);
}

//TODO: proper int -x to uint x
Node* evaluateConstantCast(Node* expression,Type* givenType){
	if( auto assigns = givenType->assignableFrom(expression,expression->returnType()) ) return assigns;

	if(auto integerLiteral = expression->asIntegerLiteral()){
		if(givenType->isInteger() || givenType->isPlatformInteger() || givenType->isUintptr()){
			integerLiteral->specifyType(givenType);
		}
		else if(givenType->isFloat())
			return int2float(integerLiteral,givenType);
		else if(givenType->isChar())
			return int2char(integerLiteral,givenType);
	}
	else if( auto floatingLiteral = expression->asFloatingPointLiteral() ){
		if(givenType->isFloat()) floatingLiteral->specifyType(givenType);
		else if(givenType->isInteger() || givenType->isPlatformInteger() || givenType->isUintptr())
			return float2int(floatingLiteral,givenType);
		else if(givenType->isChar())
			return float2char(floatingLiteral,givenType);
	}
	else if( auto characterLiteral = expression->asCharacterLiteral() ){
		if(givenType->isChar()) characterLiteral->specifyType(givenType);
		else if(givenType->isInteger() || givenType->isPlatformInteger() || givenType->isUintptr())
			return char2int(characterLiteral,givenType);
		else if(givenType->isFloat())
			return char2float(characterLiteral,givenType);
	}
	else if( auto stringLiteral = expression->asStringLiteral() ){
		if(givenType->isLinearSequence()) stringLiteral->specifyType(givenType);
	}
	else if( auto boolLiteral = expression->asBoolExpression() ){
		if(givenType->isInteger() || givenType->isPlatformInteger() || givenType->isUintptr())
			return bool2int(boolLiteral,givenType);
	}
	return expression;
}

/**
* Type validity checks
*/
bool isValidType(Type* type){
	if(type->type == Type::NODE) return false;
	if(type->isTrait()) return false;
	return true;
}
bool Type::isValidTypeForVariable(){
	if(type == NODE) return false;
	return true;
}
bool Type::isValidTypeForArgument(){
	if(type == VOID) return false;
	if(type == NODE) return false;
	return true;
}
bool Type::isValidTypeForReturn(){
	bool result = isValidType(this);
	if(type == TYPE) result = false;
	return result;
}
bool Type::isValidTypeForField(){
	bool result = isValidType(this);
	if(type == VOID)      result = false;
	else if(type == TYPE) result = false;
	return result;
}

/**
* Function pointer type
*/
FunctionPointer* FunctionPointer::get(Type* argument,Type* ret,data::ast::Function::CallConvention cc){
	auto type = new FunctionPointer();
	type->argument = argument;
	type->_returns = ret;
	type->cc = cc;
	return type;
}
FunctionPointer* Type::asFunctionPointer(){
	return type == FUNCTION_POINTER? static_cast<FunctionPointer*>(this) : nullptr;
}


/**
* Static array type
*/
StaticArray* StaticArray::get(Type* next,size_t N){
	assert(N);
	auto t = new StaticArray();
	t->argument = next;
	t->size = N;
	return t;
}
StaticArray* Type::asStaticArray(){
	return type == STATIC_ARRAY? static_cast<StaticArray*>(this) : nullptr;
}


/**
* Anonymous records/variants
*/
std::vector<std::pair<Type**,size_t>>    anonymousRecordTypes ;
std::vector<std::pair<SymbolID*,size_t>> anonymousRecordFields;

AnonymousAggregate::AnonymousAggregate(Type** t,SymbolID* fs,size_t n,bool isVariant): Type(isVariant? ANONYMOUS_VARIANT: ANONYMOUS_RECORD),types(t),fields(fs),numberOfFields(n) {
	assert(n > 1);
	if(!isVariant){
		auto first = t[0];
		for(auto i = t + 1; i < (t+n);i++){
			if(!first->isSame(*i)) return;
		}
		setFlag(ALL_SAME);
	}
}
AnonymousAggregate* Type::asAnonymousRecord(){
	return type == ANONYMOUS_RECORD? static_cast<AnonymousAggregate*>(this) : nullptr;
}
int AnonymousAggregate::lookupField(const SymbolID fieldName) const {
	if(fields){
		for(auto i = fields;i!= (fields+numberOfFields);i++){
			if( (*i) == fieldName ) return int(i - fields);
		}
	}
	return -1;
}
AnonymousAggregate* AnonymousAggregate::create(Field* fields,size_t fieldsCount,bool isVariant){
	assert(fieldsCount > 1);
	auto end = fields + fieldsCount;

	//Check to see if the record has named fields
	auto areFieldsUnnamed = true;
	for(auto i = fields;i!=end;i++){
		if(!(*i).name.isNull()) areFieldsUnnamed = false;
	}

	//find the corresponding type array
	Type** typeArray = nullptr;
	for(auto i = anonymousRecordTypes.begin();i!=anonymousRecordTypes.end();i++){
		if((*i).second == fieldsCount){
			auto otherFields = (*i).first;
			bool allTypesSame = true;
			for(size_t j=0;j<fieldsCount;j++){
				if(!(otherFields[j]->isSame(fields[j].type))){
					allTypesSame = false;
					break;
				}
			}
			if(allTypesSame){
				typeArray = otherFields;
				break;
			}
		}
	}
	if(!typeArray){
		typeArray = (Type**)System::malloc(sizeof(Type*)*fieldsCount);
		for(size_t j=0;j<fieldsCount;j++) typeArray[j] = fields[j].type;
		anonymousRecordTypes.push_back(std::make_pair(typeArray,fieldsCount));
	}

	if(areFieldsUnnamed) return new AnonymousAggregate(typeArray,nullptr,fieldsCount,isVariant);

	//find the corresponding field array
	SymbolID* symbolArray = nullptr;
	for(auto i = anonymousRecordFields.begin();i!=anonymousRecordFields.end();i++){
		if((*i).second == fieldsCount){
			auto otherFields = (*i).first;
			bool allSymbolsSame = true;
			for(size_t j=0;j<fieldsCount;j++){
				if(!(otherFields[j] == fields[j].name)){
					allSymbolsSame = false;
					break;
				}
			}
			if(allSymbolsSame){
				symbolArray = otherFields;
				break;
			}
		}
	}
	if(!symbolArray){
		symbolArray = (SymbolID*)System::malloc(sizeof(SymbolID)*fieldsCount);
		for(size_t j=0;j<fieldsCount;j++) symbolArray[j] = fields[j].name;
		anonymousRecordFields.push_back(std::make_pair(symbolArray,fieldsCount));
	}
	return new AnonymousAggregate(typeArray,symbolArray,fieldsCount,isVariant);
}
AnonymousAggregate* AnonymousAggregate::getVector(Type* type,size_t elementsCount){
	std::vector<Field> fields;
	Field field = { SymbolID(),type };
	fields.resize(elementsCount,field);
	auto aggr = create(fields.begin()._Ptr,elementsCount);
	aggr->setFlag(GEN_REWRITE_AS_VECTOR);
	return aggr;
}

/**
* Record(class like) type
*/
Record::Record() : DeclaredType(Type::RECORD) {
}
Record* Type::asRecord(){
	return type == RECORD? static_cast<Record*>(this) : nullptr;
}
int Record::lookupField(const SymbolID fieldName) const {
	for(size_t i = 0;i<fields.size();i++){
		if( fields[i].name == fieldName ) return int(i);
	}
	return -1;
}
void Record::add(const Field& var){
	assert(!isResolved());
	fields.push_back(var);
}
Record::Field Record::Field::duplicate(DuplicationModifiers* mods) const{
	Field result;
	result.name = name;
	result.type = type.duplicate(mods);
	result.isExtending = isExtending;
	result.isPrivate   = isPrivate;
	result.isReadonly  = isReadonly;
	result.initializer = initializer;
	return result;
}
DeclaredType* Record::duplicate(DuplicationModifiers* mods) const {
	auto rec= new Record();
	rec->flags = flags;
	rec->fields.reserve(fields.size());
	for(auto i = fields.begin();i!=fields.end();++i) rec->fields.push_back((*i).duplicate(mods));
	return rec;
}

/**
* Trait(concept like) type
*/
Trait::Trait(Scope* templateDeclaration) : DeclaredType(Type::TRAIT) {
	this->templateDeclaration = templateDeclaration;
}
Trait* Type::asTrait(){
	return type == TRAIT? static_cast<Trait*>(this) : nullptr;
}
void Trait::makeImplicit(){
	flags|=IS_IMPLICIT;
}
size_t Trait::numberOfTemplateParameters(){
	return templateDeclaration? templateDeclaration->numberOfDefinitions() : 0;
}
DeclaredType* Trait::duplicate(DuplicationModifiers* mods) const {
	auto dup = new Trait(templateDeclaration);
	dup->flags = flags;
	for(auto i = methods.begin();i!=methods.end();++i) dup->methods.push_back((*i)->reallyDuplicate(mods,false));
	return dup;
}

/**
* Variant type
*/
Variant::Variant() : DeclaredType(Type::VARIANT) {
}
Variant* Type::asVariant(){
	return type == VARIANT? static_cast<Variant*>(this) : nullptr;
}
DeclaredType* Variant::duplicate(DuplicationModifiers* mods) const{
	auto dup = new Variant();
	dup->flags = flags;
	dup->numberOfOptions = numberOfOptions;
	return dup;
}

/**
* Variant option
*/
VariantOption::VariantOption(Variant* variant,int id) : DeclaredType(VARIANT_OPTION) {
	this->owner  = variant;
	this->optionID = id;
	setFlag(IS_RESOLVED);
}
DeclaredType* VariantOption::duplicate(DuplicationModifiers* mods) const{
	return const_cast<VariantOption*>(this);
}
DeclaredType* VariantOption::resolve(Resolver* resolver) {
	return this;
}


/**
* Type declaration node
*/
TypeDeclaration::TypeDeclaration(DeclaredType* type,SymbolID name,bool isParametrized) : PrefixDefinition(name,Location()), _type(type),optionalStaticBlock(nullptr) { 
	_type->declaration = this; 
	if(isParametrized) setFlag(PARAMETRIZED);
}
Node*  TypeDeclaration::createReference(){
	return new TypeReference(_type);
}
Node*  TypeDeclaration::duplicate(DuplicationModifiers* mods) const {
	BlockExpression* sb = optionalStaticBlock? optionalStaticBlock->duplicate(mods)->asBlockExpression() : nullptr;
	auto dup = new TypeDeclaration(_type->duplicate(mods),label());
	dup->optionalStaticBlock = sb;
	for(auto i = extendedConcepts.begin();i!=extendedConcepts.end();++i){
		dup->extendedConcepts.push_back((*i).duplicate(mods));
	}
	mods->duplicateDefinition(const_cast<TypeDeclaration*>(this),dup);
	return copyProperties(dup);
}
Function* TypeDeclaration::parametrization() const { 
	return parentNode->asBlockExpression()->scope->functionOwner(); 
}
data::ast::Search::Result TypeDeclaration::extendsConcept(Trait* concept){
	for(auto i = extendedConcepts.begin();i!=extendedConcepts.end();++i){
		if((*i).isPattern()){
			if((*i).pattern->asTypeReference()->type->asTrait() == concept)
				return data::ast::Search::Found;
		}
		else return data::ast::Search::NotAllElementsResolved;
	}
	return data::ast::Search::NotFound;
}
